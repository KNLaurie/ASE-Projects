import torch, torchvision, torchvision.transforms as transforms, torch.nn as nn, torch.nn.functional as F, torch.optim as optim, matplotlib.pyplot as plt
import random, numpy as np, math, gym
from gym import wrappers

#--------------------IMAGE PREPROCESSING-------------------------

class Frame_pro():
    def __ init__(self, frame):
        self.frame = frame
    
    def to_gray(self, rgb):
        gray = np.dot(rgb[...,:3], [0.299, 0.587, 0.114])
        return gray


    def process(self):
        frame = imresize(self.frame, (110, 84, 3))
        frame = to_gray(frame)
        frame = frame[20:104]
        return frame


#-------------------NETWORK--------------------------------------

class NN(nn.Module):
    def __init__(self, num_actions, input_size = 4, train = True):
        super(NN, self).__init__()
        
        self.conv1 = nn.Conv2D(input_size, 32, 8, 4)
        self.conv2 = nn.Conv2D(32, 64, 4, 1)
        self.conv3 = nn.Conv2D(64, 64, 3, 1)
        
        self.fc1 = nn.Linear(64 * 7 * 7, 1500)
        self.fc2 = nn.Linear(1500, num_actions)
    
    def forward(self, x):
        if train == False:
            
        h= F.relu(self.conv1(x))
        h= F.relu(self.conv2(h))
        h= F.relu(self.conv3(h))
        
        h=h.view(x.size(0), -1)
        h= F.relu(self.fc1(h))
        h= self.fc2(h)
        
        return h

#------------------------MEMORY----------------------------------

class Memory():
    def __init__(self, capacity):
        
